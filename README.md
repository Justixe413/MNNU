### 一、Day2

#### 1.Python2.x和Python3.x版本的区别

> |                         | Python2.x                                                    | Python3.x                                                   |
> | :---------------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
> | 输出语句                | print                                                        | print()                                                     |
> | 不等于运算符            | !=和<>                                                       | !=                                                          |
> | 字符串类型              | ASCII和Unicode                                               | 默认使用UTF-8编码，它可以很好地支持中文或其他非英文字符     |
> | 运算符  /               | 使用运算符"/“进行除法运算时，整数相除结果为整数，浮点数相除结果为浮点数 | 使用运算符"/“进行除法运算时， 整数之间相除也是浮点数        |
> | 整型                    | int，long                                                    | int                                                         |
> | range作用               | 返回列表                                                     | 返回range可迭代对象                                         |
> | 八进制字面量            | 01000和0o1000格式都可使用                                    | 只能使用0o1000格式                                          |
> | repr函数                | 双反引号``可以替代repr函数                                   | 去掉了双反引号的表示方法，只能用repr方法                    |
> | input                   | 通过input 输入的类型是 int，只有通过 `raw_input()`输入的类型才是str | 通过input输入的类型都是是str，去掉了`row_input()`方法       |
> | 比较符                  | 任意两个对象都可以比较，11 < 'test'返回True                  | 只有同一数据类型的对象可以比较，11 < 'test'报错             |
> | 列表推导                | [n for n in a,b]                                             | [n for n in (a,b)]或[n for n in [a,b]]                      |
> | next()函数和.next()方法 | 可以用 next(my_generator) 和 my_generator.next() 两种方式    | 只能用 next(my_generator)这种方式                           |
> | 文件读取                | py2中字符可以直接写到文件中,unicode需要编码才可以写入文件,读文件需要解码 | py3打开文件，指定编码格式自动编码，写入文件不需要编码和解码 |
> | 二进制表示              | 字符串直接是2进制,unicode编码需要前面加上u                   | 2进制需要前面加上b                                          |
> | 软件环境                | 重复代码,语言不统一,不支持中文                               | 代码不重复,语言统一,支持中文                                |

#### 2.Python的特点

> - Python是一种解释性语言【开发过程中没有了编译这个环节，类似于PHP或者Perl语言】
> - Python是交互式语言【可以在一个Python提示符，直接互动执行程序】
> - Python是面向对象语言【Python支持面向对象的风格或代码封装在对象的编程技术】
> - Python是初学者的语言【Python对于初级程序员而言，是一种伟大的语言，他支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏】
> - Python是跨平台的【它可以运行在Windows、Mac os或者Linux系统上，也就是说，在Windows上书写的Python程序，在Linux上也是可以运行的，类似于Java】

#### 3.Python优缺点

> 优点：	
>
> - 易于学习【Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单】
> - 易于阅读【Python代码定义的更清晰】
> - 易于维护【Python的成功在于它的源代码是相当容易维护的】
> - 一个广泛的标准库【Python的最大优势之一是丰富的库，跨平台的，在nuix、weindows和mac os上的兼容性很好】
> - 互动模式【互动模式的支持，可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片段】
> - 可移植性【基于其开发源代码的特性，Python已经被移植到许多平台】
> - 可扩展性【如果需要一段运行很快的关键代码，或者想要编写一些不愿开发的算法，可以使用C或者C++完成那部分程序，然后从你的Python程序中调用】
> - 数据库【Python提供所有主要的商业数据库的接口】
> - GUI编程（图形化界面）【Python支持GUI可以创建和移植到许多系统调用】
> - 可嵌入性【可以将Python嵌入到C或者C++程序，让你程序的用户获得“脚本化”的能力】
>
> 	点：	
>
> - 运行速度慢【和C程序相比非常慢，因为Python是解释型语言，代码在执行时会一行一行的翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢，而C程序是运行前直接编译成CPU能执行的机器码，所以非常快】
> - 代码不能加密【如果要发布Python程序，实际上就是发布源代码，这一点跟C语言不通，C语言不用发布源代码，只需要把编译后的机器码（就是windows上常见的xxx.exe）发布出去，要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去】

#### 4.Python应用场景

> - Web开发【通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序】
>
> - 操作系统管理、服务器运维的自动化脚本【在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本】
>
> - 网络爬虫【Python有大量的HTTP请求处理库和HTML解析库，并且有成熟高效的爬虫框架Scrapy和分布式解决方案scrapy-redis，在爬虫的应用方面非常广泛】
>
> - 科学计算（数据分析）【NumPy、SciPy、Pandas、Matplotlib可以让Python程序员编写科学计算程序】
>
> - 桌面软件【PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器】
>
> - 服务器软件（网络软件）【Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件】
>
> - 游戏【很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型】
>
>   搜狐、豆瓣、腾讯、网易、百度、阿里、淘宝、土豆、新浪等都在内部大量的使用Python

#### 5.标识符

> 概念：计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系
>
> 合法标识符的命名规则：
>
> - 只能由数字，字母和下划线组成
> - 不可以是除了下划线之外的其他特殊字符
> - 开头不能是数字或者空格
> - 不能是Python的关键字
> - 严格区分大小写    age   Age
>
> 标识符的命名规范：
>
> - 尽量做到见名知意【具有描述性】
> - 遵守一定的命名规范
>   - Python官方推荐的命名方式：变量名，函数名和文件名全小写，使用下划线连接，如：stu_name     check_qq
>   - 驼峰命名法：不同的单词之间使用首字母大写的方式进行分隔，又分为大驼峰和小驼峰，比如：stuName就是小驼峰，StuName就是大驼峰，小驼峰常用于变量或者函数的命名，大驼峰常用于类的命名

#### 6.交换两个变量的值

> ```python
> 方式一：Python特有的语法
> 
> a = 10
> b = 20
> a,b = b,a
> print(a,b)  # 20 10
> 
> 方式二：定义临时变量，解释方式一的工作原理
> 
> a = 10
> b = 20
> temp = a
> a = b
> b = temp
> print(a,b)
> 
> 方式三：加减法
> 
> a = 10
> b = 20
> a = a + b  # a = 10 + 20
> b = a - b  # b = 30 - 20 = 10
> a = a - b  # a = 30 - 10 = 20
> print(a,b)
> ```

#### 7.变量使用练习题

> ```python
> m = 4
> n = 6
> m,n = n,m
> print(m,n)   # 6 4
> 
> m,m = 7,8
> print(m,n)   # 8  4
> ```

#### 8.简述Python的内存管理机制

> 如果内存中的某个数据没有变量【引用】指向它，则该数据会等待系统的垃圾回收机制回收
> 则该数据占用的空间也会被释放掉

### 二、Day3

#### 1.进制练习题

> ```python
> print(int("0b110220",base=16))
> ```

### 三、Day4

#### 1.简述if语句的单分支，双分支和多分支之间的区别

> 单分支：要么执行，要么不执行，当条件成立时则执行代码块中的语句，反之则不执行
> 双分支：二选一，当条件成立，则执行if分支的语句，反之执行else分支的语句
> 多分支：多选一，从上往下依次判断，只要有一个条件成立，则执行对应的分支语句，执行完毕则整个if语句全部结束

#### 2.break和continue

> break: 跳出for和while的循环体【直接跳出整个循环，继续执行循环后面的代码】
> continue: 跳过当前正在执行的循环，然后继续进行下一轮循环【结束本次循环，继续执行下一次循环】

#### 3.短路原则

> a.A and B,如果A为False，不需要计算B的值，整个表达式的结果为False
>
> b.A or B,如果A为True，不需要计算B的值，整个表达式的结果为True
>
> c.and和or混合使用
>
> ​	1>表达式从左往右运算，如果or的左侧为True，则会短路or后面所有的表达式【不管是and还是or连接】，整个表达式的结果为True
>
> ​	2>表达式从左往右运算,如果and的左侧为False,则短路后面所有的and，直到or出现，接着计算
>
> ​	3>如果or的左侧为False，或者and的左侧为True，则不能使用短路逻辑判断
>
> 注意：所有被短路的表达式均不会被输出

#### 4.简述is和==的区别

> is:比较的是两个变量【对象】的地址
> ==：比较的是两个变量【对象】的内容
> 如果两个变量的地址相同，则这两个变量的内容一定相同
> 如果两个变量的内容相同，则这两个变量的地址不一定相同

### 四、Day5

#### 1.列表“+”练习题

> ```python
> 组合：+
> 
> list1 = [1,2,4]
> list2 = ["a","b","c"]
> print(list1 + list2)
> print(list1,list2)
> ```

#### 2.列表添加元素的时候，append和extend之间的区别

> a.append可以追加任意类型的元素，而extend只能追加可迭代对象
> b.当添加可迭代对象的时候，append会将整个可迭代对象添加进去，但是extend只会添加可迭代对象中的元素
> c.二者都是将元素追加到列表的末尾
> d.二者都是在原列表的基础上进行添加的

#### 3.深拷贝和浅拷贝

> 浅拷贝
> 列表.copy()和copy.copy()
>
> 对于一维列表，一个列表更改，另一个列表不受影响
> 对于二维列表，一个列表更改【最里层的元素】，另一个列表会随着更改
>
> 深拷贝copy.deepcopy()：
>
> 不管是几维列表，其中一个列表更改，对另一个列表没有任何影响

#### 4.深拷贝和浅拷贝-练习题1

> ```python
> a = [1,2,3]
> b = [4,5]
> c = [a,b]
> d = c
> e = c.copy()
> a.append(10)
> print(c,d,e)
> """
> c:[[1,2,3,10],[4,5]]
> d:[[1,2,3,10],[4,5]]
> e:[[1,2,3,10],[4,5]]
> """
> ```

#### 5.深拷贝和浅拷贝-练习题2

> ```python
> a = [1,2,["a","b"]]
> b = a
> c = copy.deepcopy(a)
> a[-1].append(3)
> print(b)
> print(c)
> """
> b:[1,2,["a","b",3]]
> c:[1,2,["a","b"]]
> """
> ```

#### 6.深拷贝和浅拷贝-练习题3

> ```python
> a = [1,2,["a","b"]]
> b = a
> c = copy.deepcopy(a)
> a.append(3)
> print(b)
> print(c)
> """
> b:[1,2,["a","b"],3]
> c:[1,2,["a","b"]]
> """
> ```

### 五、Day6

#### 1.深拷贝和浅拷贝-练习题4

> ```python
> import  copy
> list1 = [11,22,[33,44]]
> list2 = list1
> list3 = list1.copy()
> list4 = copy.copy(list1)
> list5 = copy.deepcopy(list1)
> ```

#### 2.简单算法-冒泡排序

> ```python
> list1 = [34,54,6,5,65,100,4,19,50,3]
> 
> #冒泡排序，以升序为例
> 
> #外层循环：控制比较的轮数
> for i in range(len(list1) - 1):
>     #内层循环：控制每一轮比较的次数，兼顾参与比较的下标
>     for j in range(len(list1) - 1 - i):
>         #比较：只要符合条件则交换位置，
>         # 如果下标小的元素 > 下标大的元素，则交换位置
>         if list1[j] > list1[j + 1]:
>             list1[j],list1[j + 1] = list1[j + 1],list1[j]
> print(list1)
> ```

#### 3.简单算法-选择排序

> ```python
> list1 = [34,54,6,5,65,100,4,19,50,3]
> 
> # 选择排序，以升序为例
> 
> # 外层循环：控制比较的是轮数
> for i in range(len(list1) - 1):
>     # 内层循环：控制每一轮比较的次数，兼顾参与比较的下标
>     for j in range(i + 1,len(list1)):
>         # 比较，交换
>         # 如果下标小的元素 > 下标大的元素，则交换位置
>         if list1[i] > list1[j]:
>             list1[i],list1[j] = list1[j],list1[i]
> print(list1)
> ```

#### 4.简单算法-顺序查找

> ```python
> # 1.需求：查找指定元素在列表中的位置
> list1 = [5,6,5,6,24,17,56,4]
> key = 6
> for i in range(len(list1)):
>     if key == list1[i]:
>         print("%d在列表中的位置为：%d" % (key,i))
> 
> # 2.需求：模拟系统的index功能，只需要查找元素在列表中第一次出现的下标，如果查找不到，打印not found
> # 列表.index(元素)，返回指定元素在列表中第一次出现的下标
> list1 = [5,6,5,6,24,17,56,4]
> key = 10
> for i in range(len(list1)):
>     if key == list1[i]:
>         print("%d在列表中的位置为：%d" % (key,i))
>         break
> else:
>     print("not found")
> 
> # 3.需求：查找一个数字列表中的最大值以及对应的下标
> num_list = [34,6,546,5,100,16,77]
> max_value = num_list[0]
> max_index = 0
> for i in range(1,len(num_list)):
>     if num_list[i] > max_value:
>         max_value = num_list[i]
>         max_index = i
> print("最大值%d在列表中的位置为：%d" % (max_value,max_index))
> 
> # 4.需求：查找一个数字列表中的第二大值以及对应的下标
> num_list = [34,6,546,5,100,546,546,16,77]
> # 备份
> new_list = num_list.copy()
> 
> # 升序排序
> for i in range(len(new_list) - 1):
>     for j in range(len(new_list) - 1 - i):
>         if new_list[j] > new_list[j + 1]:
>             new_list[j],new_list[j + 1] = new_list[j + 1],new_list[j]
> print(new_list)
> 
> # 获取最大值
> max_value = new_list[-1]
> 
> # 统计最大值的个数
> max_count = new_list.count(max_value)
> 
> # 获取第二大值
> second_value = new_list[-(max_count + 1)]
> 
> # 查找在列表中的位置:顺序查找
> for i in range(len(num_list)):
>     if second_value == num_list[i]:
>         print("第二大值%d在列表中的下标为:%d" % (second_value,i))
> ```

#### 5.简单算法-二分法查找

> ```python
> list1 = [45,65,7,67,100,5,3,2,5,35]
> # 以升序为例
> list1.sort()
> # 待查找元素
> key = 66
> # 定义变量，表示索引的最大值和最小值
> left = 0
> right = len(list1) - 1
> 
> # left和right会一直改变，在改变的过程中，直到left == right,还未找到指定元素，则说明该元素不存在
> while left <= right:
>     # 计算中间下标
>     middle = (left + right) // 2
> 
>     # 比较
>     if list1[middle] < key:
>         # 重置left的值
>         left = middle + 1
>     elif list1[middle] > key:
>         # 重置right的值
>         right = middle - 1
>     else:
>         print("%d索引为：%d" % (key,middle))
>         # 如果查找到，则可以提前结束循环
>         break
> else:
>     print("%d在列表中不存在" % (key))
> ```

#### 6.创建字典的方式

> ```python
> # 方式一
> dict1 = {"name":"张三","age":10,"score":100}
> print(dict1)
> 
> # 方式二
> dict2 = {}
> dict2["name"] = "张三"
> dict2["age"] = 10
> dict2["score"] = 88
> print(dict2)
> 
> # 方式三
> # dict(key=value....)
> dict3 = dict(name="lisi",age=9,score=66)
> print(dict3)
> 
> # 方式四
> # dict([(key1,value1),(key2,value2)....])
> dict4 = dict([("one",10),("two",20),("three",30)])
> print(dict4)
> 
> # 方式五
> # dict(zip(seq1所有的key,seq2所有的value))，seq1和seq2可以是列表，也可以是元组
> dict5 = dict(zip(["111","222","333"],[1,2,3]))
> print(dict5)
> dict5 = dict(zip(["111","222","333"],[1,2,3,4]))
> print(dict5)
> dict5 = dict(zip(["111","222","333","444"],[1,2,3]))
> print(dict5)
> 
> dict5 = dict(zip(("111","222","333"),(1,2,3)))
> print(dict5)
> ```

### 六、Day7

#### 1.dict()和fromkeys的区别

> ```python
> d2 = dict(zip([22,33],["a","b"]))
> print(d2)  #{22: 'a', 33: 'b'}
> d2 = dict.fromkeys([22,33],["a","b"])
> print(d2)  #{22: ['a', 'b'], 33: ['a', 'b']}
> ```

#### 2.字典推导式练习题

> ```python
> # 需求：已知字典dict1 = {"a":10,"b":20},交换key和value，生成一个新的字典
> # 方式一
> dict1 = {"a":10,"b":20}
> dict2 = {}
> for key,value in dict1.items():
>     dict2[value] = key
> print(dict2)
> 
> # 方式二
> dict21 = {value:key for key,value in dict1.items()}
> print(dict21)
> ```

#### 3.内置函数

> ```python
> # 请列举出至少5个内置函数，并解释他们的作用
> 
> # 1.abs()绝对值
> print(abs(-10))
> 
> # 2.max()/min()
> print(max([3,54,645]))
> print(max(4,54,6,5,6))
> 
> # 3.pow(x,y)，求x的y次方
> print(pow(5,3))
> print(5 ** 3)
> 
> # 4.sum(iterable,value),将容器中的所有的元素求和，并加上value，value可以省略
> print(sum([3,4,5]))
> print(sum((3,4,5)))
> print(sum({3,4,5}))
> print(sum([3,4,5],10))
> 
> # 5.round(v1,v2),v2省略，则返回一个整数。v2如果不省略，表示保留小数点后几位
> # 返回四舍五入的数据
> print(round(6.34))
> print(round(6.64))
> print(round(6.64,1))
> print(round(6.36,1))
> ```

#### 4.字符系统功能练习题

> ```python
> str1 = "hello"
> str1.upper()
> print(str1)
> ```

### 七、Day9

#### 1.打包【封包】和拆包，pack和unpack

> ```python
> d2 = dict(zip([22,33],["a","b"]))
> print(d2)  #{22: 'a', 33: 'b'}
> d2 = dict.fromkeys([22,33],["a","b"])
> print(d2)  #{22: ['a', 'b'], 33: ['a', 'b']}
> ```

#### 2.值传递和引用传递

> 值传递：传参的时候，实参是不可变的数据类型,如：int,float,bool,tuple,str等,
>                当形参发生修改，对实参没有影响
> 引用传递：传参的时候，实参是可变的数据类型，如：list,dict,set等,
>                     当形参发生修改【容器中的内容】，则实参会随着修改

#### 3.匿名函数练习题

> ```python
> def func():
>     a = []
>     for i in range(5):
>         a.append(lambda x:i * x)
>     return a
> 
> result = func()
> ```

#### 4.什么是匿名函数，优缺点

> 是一个lambda表达式
> 本质上还是一个函数，可以设置参数，也可以调用
> 表达式本身就是函数的运算结果
> 优点：
>     简化代码
>     减少内存空间的使用
> 缺点：
>     只能实现简单的逻辑，逻辑一旦复杂，代码的可读性会降低，则不建议使用

### 八、Day10

#### 1.全局变量和局部变量练习题

> ```python
> """
> n = 9
> def test():
>     #报错的原因：当局部变量和全局变量重名时，在函数内部访问，就近访问局部变量，但是
>     # n += 1相当于n = n + 1,先计算 n + 1,根据就近原则，应该访问局部变量，但是局部变量还未被定义，则出现了冲突
>     #UnboundLocalError: local variable 'n' referenced before assignment
>     n += 1   # n = n + 1
>     print(f"内部：{n}")
> test()
> print(f"外部：{n}")
> """
> ```

#### 2.nonlocal练习题

> ```python
> x = 1    # global
> def outter():
>     x = 2   # enclosing
>     def inner():
>         # nonlocal声明指定的变量不是局部作用域的变量，而是函数作用域的，
>         # x = 3中的x和x=2中的x是同一个变量，所以x = 3就相当于对x = 2中的x进行了重新赋值
>         nonlocal x
>         x = 3   # local
>         print("inner:%d" % (x))
>     inner()
>     print("outter:%d" % (x))
> 
> outter()
> print("全局：%d" % (x))
> """
> inner:3
> outter:3
> 全局：1
> """
> ```

#### 3.简述可迭代对象和迭代器之间的区别和联系

> 可迭代对象：Iterable，可以直接作用于for循环的数据类型，如：list,tuple,dict,set,str,生成器等
> 迭代器：Iterator，可以直接作用于for循环或者可以通过next获取下一个元素的数据类型，如：生成器
>
> 联系：
>     迭代器一定是可迭代对象，可迭代对象不一定是迭代器
>     但是，可以通过iter()将不是迭代器的可迭代对象在转换为迭代器

### 九、Day13

#### 1.简述类属性(字段)和对象属性(字段)的区别和联系

> a.定义位置不同：类属性直接定义在类中，对象属性：对象动态绑定或者定义在构造函数中
> b.访问方式不同：类属性可以通过对象或者类访问，对象属性只能通过对象访问
> c.在内存中出现的时机不同：类属性随着类的加载出现在内存中，对象属性随着对象的创建出现在内存中，
>     类属性优先于对象属性出现在内存中
> d.优先级不同：当类属性和对象属性重名的情况下，对象属性的优先级高于类属性
> e.使用场景不同：如果是多个对象共享的数据则定义为类属性，如果是各个对象不同的数据则定义为对象属性

#### 2.简述普通函数和__init__的区别和联系

> 不同点：
>     a.函数名不同：普通函数的函数名可以自定义，但是，__init__是固定的，不能随意更改
>     b.调用不同：普通函数必须手动调用，__init__是在创建对象的过程中自动调用的
>     c.调用的次数：对于同一个对象而言，__init__只会被调用一次，但是，普通函数可以被无数次调用
> 相同点：
>     a.定义在类中，形参列表的第一个参数为self。都被称为实例函数
>     b.形参列表仍然可以设置默认参数，不定长参数，实参列表也可以设置关键字参数
>     c.也可以设置返回值

### 十、Day14

#### 1.@property装饰器

> ```python
> class Check():
>     @property
>     def show(self):
>         # 注意：如果函数被@property修饰，最好设置返回值
>         #return 10
>         print("showing")
> c = Check()
> # c.show()  #TypeError: 'str' object is not callable
> print(c.show)
> ```

### 十一、Day15

#### 1.面向对象语言的三大特征是什么

> 封装：将不希望被外界访问的属性私有化，在定义属性的时候在属性的前面添加两个下划线，
>       为了保证数据的安全性，提高了数据的复用性，
>       封装是定义类的准则【根据多个对象的特点，将相同的属性和行为抽取出来一个类，还可以进行属性的私有化】
> 继承：将多个相似的类中的共同的属性或者函数提取出来，形成一个父类，
>       子类将会继承父类中未被私有化的属性和函数，可以提高代码的可扩展性，可复用性，可维护性
>       继承是设计类的技巧【父类和子类，主要为了代码的重用】
> 多态：在继承的前提下，当代码运行的时候，根据传入的对象确定是哪个类，确定需要调用哪个函数
>       多态是调用函数的技巧【不同的子类可能调用不同的函数，产生不同的执行结果，
>       可以增加代码的灵活度，不会影响到类的内部设计】

#### 2.简述实例函数，类函数和静态函数中之间的区别和联系

> 相同点：
>     本质都是函数，所以默认参数，关键字参数，不定长参数都可以正常使用，也可以设置返回值
> 不同点：
>     a.是否有装饰器：类函数需要被@classmethod修饰，静态函数需要被@staticmethod修饰，实例函数不需要任何装饰器
>     b.参数列表：类函数的第一个参数必须为cls，实例函数的第一个参数必须为self，静态函数的参数没有要求
>     c.调用方式：类函数和静态函数可以通过类名或者对象调用，实例函数只能通过对象调用
>     d.使用场景不同：
>         如果需要在函数中创建当前类的对象，则选用类函数
>         如果需要封装一个工具类，建议使用类函数或者静态函数

### 十二、Day16

#### 1.练习题

> ```python
> class Person(object):
>     count = 0
>     """
>     def __init__(self,name,age)---->self表示被__new__创建出来的对象
>     """
>     # def __new__(cls, *args, **kwargs):
>     #     print("new~~~~~")
>     #     return super(Person,cls).__new__(cls)
>     # __init__本质上就是一个成员函数，可以将其转化为类函数使用，主要是为了访问类属性count
>     @classmethod
>     def __init__(cls,name,age):
>         print(cls,"init~~~~")
>         cls.count += 1
>         # 此处的name和age是类属性，并不是实例属性，对于创建对象没有任何影响
>         cls.name = name
>         cls.age = age
> 
> p1 = Person("a",10)
> print(p1)
> ```

### 十三、Day17

#### 1.常见异常

> AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
> IOError 输入/输出异常；基本上是无法打开文件
> ImportError 无法引入模块或包；基本上是路径问题或名称错误
> IndentationError 语法错误（的子类） ；代码没有正确对齐
> IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
> KeyError 试图访问字典里不存在的键
> KeyboardInterrupt Ctrl+C被按下
> NameError 使用一个还未被赋予对象的变量
> SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
> TypeError 传入对象类型与要求的不符合
> UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
> 导致你以为正在访问它
> ValueError 传入一个调用者不期望的值，即使值的类型是正确的

#### 2.try-except-finally,在try或者except中出现return

> ```python
> # 注意：如果函数中使用try-except-finally语句，并且try或者except中使用了return，finally仍然会被执行
> """
> def test():
>     try:
>         num = int(input("请输入："))
>         # return
>         print("hello")
>     except ValueError as e:
>         print(e)
>         return
>         print("fahj")
>     finally:
>         print("finally被执行了")
> test()
> """
> ```

#### 3.assert断言

> ```python
> def div(x,y):
>     # 语法：assert  表达式 ，异常信息描述
>     # 工作原理：如果表达式成立，则代码正常执行，但是如果表达式不成立，则出现一个AssertionError
>     assert y != 0,"y不能为0"
>     return x / y
> 
> print(div(5,2))
> print(div(5,0))
> print("over")
> ```

#### 4.如何自定义一个异常类

> ```python
> # a.自定义一个类，继承自BaseException或者Exception
> class MyException(BaseException):
>     # b.书写构造函数，在其中定义实例属性
>     def __init__(self,msg):
>         # c.调用父类的构造函数,主要是为了继承异常的机制
>         super().__init__()
>         # msg用于记录异常的描述信息
>         self.msg = msg
>     # d。重写__str__函数
>     def __str__(self):
>         return self.msg
> 
>     # e.定义一个实例函数，用于解决出现的问题
>     def handle(self):
>         print("问题已解决")
> try:
>     raise MyException("出现了异常")
> except MyException as e:
>     print(e)
>     e.handle()
> ```

#### 5.简述TCP和UDP之间的区别

> Transmission Control Protocol 传输控制协议,基于字节流的传输层通信协议
> 特点:
> 	a.安全的【确保接收方完全正确地获取发送方所发送的全部数据】
> 	b.面向连接的【面向连接的协议，数据传输必须要建立连接，所以在TCP中需要连接时间】要任何装饰器
>         c.数据传输的效率较低
>         d.传输数据大小限制，一旦连接建立，双方可以按统一的格式传输大的数据Transmission Control User Datagram Protocol的简称，用户数据包协议，提供面向事务的简单不可靠信息传送服务
> 特点:
> 	a.不安全【发送方所发送的数据报并不一定以相同的次序到达接收方，UDP就是将数据包发送给对方,对方不一定能接受的到】,比如：飞秋
> 	b.无连接的【s每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接】
> 	c.效率高，速度快
> 	d.UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内

#### 6.socket通信流程

> 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器
>
> 举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来了，后面的通信就是发送网页内容了

### 十四、Day19

#### 1.进程和线程之间的关系

> a.一个程序运行后至少有一个进程
> b.一个进程可以包含多个线程，但是至少需要有一个线程，否则这个进程是没有意义的
> c.进程间不能共享资源，但线程之间可以
> d.系统创建进程需要为该进程重新分配系统资源，而创建线程则容易的多，因此使用线程实现多任务并发比多进程的效率高

#### 2.多任务的4种实现方式

> a.多进程模式：启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务
> b.多线程模式：启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务
> c.协程模式：启动一个进程，启动一个线程，但是借助于函数生成器【yield】可以执行多个子任务
> d.多进程+多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了

#### 3.fork的优缺点

> fork的缺点：
> 	a.兼容性差：只能在Linux下使用，Windows系统无法使用
> 	b.扩展性差：当创建多个进程对象的时候，管理较为复杂
> 	c.会产生“孤儿”进程或者“僵尸”进程，需要手动回收系统资源
> fork的优点：
> 	是系统自带的更加接近底层的创建进程的方式，运行效率高

### 十五、Web-Day1

#### 1.网页的实现

> 网页主要由三个部分组成：结构、表现、行为
> 	结构：网页的结构和内容，如：一个网页中包含文字。图片，音视频等，由HTML实现
> 	表现：设定网页的样式，如：字体的大小，颜色，图片形状，由CSS实现
> 	行为：控制用户和网页的交互，如：点击按钮请求等，由JavaScript实现
> 	总之，结构决定了网页是什么，表现决定了网页是什么样子，行为决定网页能做什么

#### 2.HTML的操作思想

> 网页主要由三个部分组成：结构、表现、行为
> 	网页中有很多的数据，不同f的数据可能需要不同的显示效果，这个时候需要使用标签将需要操作的数据封装起来，通过修改标签的属性值实现标签内数据样式的变化
> 	一个标签就相当于是一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内数据样式的变化

#### 3.常用请求方式get和post之间的区别

> get:
> 	地址栏：请求参数会在请求地址的后面进行拼接，拼接方式：path?name=xxx&pwd=xxx
> 	不安全
> 	效率高
> 	对数据的大小有限制，不适合上传较大的数据，一般用于数据的查询
> post:
> 	地址栏：请求参数单独处理
> 	安全
> 	效率低
> 	理论上对数据的大小没有限制，一般用于插入数据删除修改，上传文件等操作

### 十六、Web-Day2

#### 1.CSS样式权重

> 行内样式的权重：1000
> id选择器的权重：100
> class选择器的权重：10
> 标签名称选择器的权重：1
> 包含或者组合选择器的权重：基本选择器的权重之和
> 注意：涉及到权重【优先级】，一般针对的是对于同一个标签，在不同的选择器中设置了同种样式

### 十七、Web-Day3

#### 1.js的组成

> a.ECMAScript
> 	基本语法：变量，运算符，语句，函数
> b.BOM
> 	Broswer Object Model,浏览器对象模型
> c.DOM【重点】
> 	Document Object Model:文档对象模型

### 十八、Web-Day4

#### 1.var或者let声明变量

> var:使用较多，声明一个变量，该变量的范围限于在声明的块中【script标签】
> 	特点：先声明，然后赋值
> let:使用较少，也是声明一个变量
> 	特点：先声明，然后赋值
> 使用let或者var定义变量，如果变量未被赋值，该变量的值为undefined，本身是一种数据类型

#### 2.NaN：not a Number

> ```html
> var c = 0 / 0;
> document.write(c);
> ```

#### 3.==与===的区别

>  ==：模糊比较，比较的是内容，不比较类型
> ===：精确比较，同时比较内容和类型，当内容和类型都相同的时候才返回true

### 十九、Web-Day6

#### 1.节点

> 元素节点：
> 	nodeValue:null
> 	nodeType：1
> 	nodeName:元素名称的大写
> 属性节点：
> 	nodeValue:属性的值
> 	nodeType：2
> 	nodeName:属性名称【id,class】
> 文本节点：
> 	nodeValue:文本值
> 	nodeType：3
> 	nodeName:#text
> 注释节点：nodeType为8
>
> 文档节点：nodeType为9

### 二十、Web-Day7

#### 1.事件传递的模式：冒泡模式和捕获模式

> false:从里向外逐个触发，这种事件的模式叫做冒泡模式，3 --->2 ---->1
> true:从外向里逐个触发，这种事件的模式叫做捕获模式,1 --->2----->3
> 现代的浏览器默认使用冒泡模式，常用false

### 二十一、Web-Day8

#### 1.remove()和detach()

> ​	相同点：只是从html结构中删除指定的标签，但是对应的jQuery对象会被保留下来，在后期的代码中可以使用该对象
> 	不同点：remove会将指定标签绑定的事件或者附加的数据都会删除掉，detach会将指定标签绑定的事件或者附加的数据保留下来

### 二十二、Web-Day10

#### 1.AJAX 的工作原理

> C/S:Client   Server   客户端服务端
>
> B/S:Broswer   Server	浏览器服务端
>
> ![ajax工作原理](F:/%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%902/uTorrent/Web-Day10/notes/ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png)

#### 2.ajax 的优缺点

> #### 优点：
>
> - AJAX使用Javascript技术向服务器发送异步请求；
> - AJAX无须刷新整个页面；
> - 因为服务器响应内容不再是整个页面，而是页面中的局部，所以AJAX性能高；
>
> #### 缺点：
>
> - AJAX并不适合所有场景，很多时候还是要使用同步交互；
> - AJAX虽然提高了用户体验，但无形中向服务器发送的请求次数增多了，导致服务器压力增大；
> - 因为AJAX是在浏览器中使用Javascript技术完成的，所以还需要处理浏览器兼容性问题
